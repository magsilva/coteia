<?php

/**
 * (c) 2004-2005 John W. Stamey, Bryan T. Saunders, and Matthew Cameron.
 * This program is licensed under the GNU General Public License.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/**
 * Java => PHP port of AOPHP v2.1
 *
 * @author: Mike Reinstein <covert_access@yahoo.com>
 * date: 03-07-2005
 */

//Boolean result = string.contains(String needle);
//String result = string.replace(String old_needle, String new_needle);
//String result = string.substring(int startIndex, int endIndex);

require_once("AdviceTable.php");
require_once("AdviceSymbol.php");
require_once("PointcutTable.php");
require_once("PointcutSymbol.php");

class AOPHPWeaver{

	var $phpDir;
	
	/**
	 * Constructor
	 *
	 * @param array $args an array of strings
	 */
	function AOPHPWeaver(){}
	
	
	
	function invoke($inputFileDirectory, $inputFilePath, $outputFilePath) {
		/*
		 * Determine Aspect File(s)
		 * Run through Aspect File(s) -> Generate Advice Symbol Table
		 *  - Only One Piece of Each type of Advice per Joinpoint
		 * Make List of Used Original Functions from Symbol Table
		 * Generate Aspect Functions
		 * Start New Temp File
		 *  - Insert Aspect Functions
		 *  - Process File
		 *    - Replace Function Calls w/ New Functions
		 * Close Out Temp File
		 */
		
		// Only Passing in Args 0 & 1
		// args[0] - Path of Original PHP File
		// args[1] - Name of Original PHP File
		// args[2] - Full Path to Generated PHP File
		//File phpInFile = new File(args[0]); // Original PHP File
		
		//$this->phpDir = $args[0];
		//these are filenames
		//$phpOutFile = $args[2];			//Generated PHP File
		//$phpInFile = $args[0].$args[1];	//input PHP file
			
		$this->phpDir = $inputFileDirectory;
			
		//Determine Need for AOPHP
		$pcTable = new PointcutTable();
		
		$AspectFilePath = '';
		$lineIn = '';

		//read the first line from the PHP input file
		$phpIn = fopen($inputFilePath, 'r');
		if ($phpIn == FALSE) {
			trigger_error('File dos not exist', E_WARNING);
			return;
		}
		
		
		if (! feof($phpIn)) {
			$lineIn = fgets($phpIn);
		}
		fclose($phpIn);
					  		
		if (strpos($lineIn, '<?aophp') !== FALSE) {
			// Get Aspect Files
			$startPos = strpos($lineIn, 'filename') + strlen('filename') + 2;
			$endPos = strpos($lineIn, '"', $startPos + 1) - $startPos;

			$AspectFilePath = substr($lineIn, $startPos, $endPos);
			$aspectFiles = explode(',', $AspectFilePath);

			// Get advice from aspect files and build advice table
			$aoTable = $this->gen_aspect_table($aspectFiles, $pcTable);
				
			$cTable = $aoTable->makeCodeTable();
			
			// Generate Aspect Functions
			$aoFunctions = $cTable->genAspectFuncs($aoTable);

			// Make New Temp File
			// Write Advice Functions to File
			// Replace Function Calls with Aspect Function Calls
			// Close File
				
			// Write New PHP File
			$phpOutFile = fopen($outputFilePath, 'w');
			$phpInFile = fopen($inputFilePath, 'r');

			// Read First Line and Throw it out
			$tempLine = fgets($phpInFile);
			
			// Write Correct First Line and AOPHP Functions
			fwrite($phpOutFile, "<?php // Generated by AOPHP\n");
			fwrite($phpOutFile, "\n$aoFunctions\n\n");
			
			// Write the rest of the Original PHP
			while (! feof($phpInFile)) {
			  	$tempLine = fgets($phpInFile);
			  	
			  	// Scan line for mention of original function name and replace with
			  	// AOPHP function name
				fwrite($phpOutFile, $cTable->scanLine($tempLine));
			}
			
			fclose($phpInFile);	
			fclose($phpOutFile);
		}
		else {
			copy($inputFilePath, $outputFilePath);
		}		
	}
	
	
	/**
	 * Get Advice From Aspect Files and Build Advice Table.
	 *
	 * @param array $aspectFiles strings that represent filnames containing advices to use.
	 * @param PointcutTable $pcTable the table containing the point cuts.
	 * @return AdviceTable the advice table containing all of the built advices.
	 */
	function gen_aspect_table($aspectFiles, &$pcTable)
	{
    	$aoTable = new AdviceTable();
    	
		foreach ($aspectFiles as $aspectFile) {
			//open file for read-only operations
			$temp = fopen($this->phpDir . $aspectFile, 'r');
			if ($temp === FALSE) {
			  trigger_error('Could not open advice file '. $this->phpDir . $aspectFile, E_ERROR);
			  return;
			}
			
			while( !feof($temp) ){
					
				//read in the next line of input from the file
				$lineIn = fgets($temp);
				
				// If Pointcut, Add to Pointcut Table
				$pc_position = strpos($lineIn,"pointcut");
				$eq_position = strpos($lineIn,"=");
				$sc_position = strpos($lineIn,";");
				if( ($pc_position !== FALSE) &&  ($eq_position !== FALSE) &&  ($sc_position !== FALSE)){
					// Get Pointcut Information
					// Syntax: pointcut name = JP | JP;
					$jpName =  trim(substr($lineIn,$pc_position+8,$eq_position-$pc_position-8));
					$jpSigs = trim(substr($eq_position+1,$sc_position - $eq_position-1));
					$pcTable->addPC(new PointcutSymbol($jpName,$jpSigs));
				}
				else if($this->startsAdvice($lineIn)){
					// If Advice, Add to Advice Table
					// Syntax: AdviceT(): JP(SIG) | JP(SIG) {...}
					$block = $this->grabAdviceBlock($lineIn, $temp);
					$adviceT = trim(substr($block, 0, strpos($block, "(")));
					$adviceJP = trim( substr($block, strpos($block,":")+1,strpos($block, "#") - strpos($block,":") - 1));
					$adviceCode = substr($block, strpos($block, "#")+1, strlen($block) - strpos($block, "#")-1);
					
					// Add Advice to Table
					// Determine if adviceJP is a Pointcut
					// if So, Replace with Pointcut Sig
					if($pcTable->contains($adviceJP)){
						$adviceJP = $pcTable->getSigs($adviceJP);
					}

					// Breakout & Breakdown Indiviual JP's to Add to Advice Table
					if(strpos($adviceJP, "|") !== FALSE){
						// Multiple JP's
						//------------------------------------------------------------
						//NEW ALGORITHM, FIND OUT IF THIS IS ACCEPTABLE
						$jpList = explode("|", $adviceJP);
						for($k = 0; $k < count($jpList);$k++){	
							$jpList[$k] = trim($jpList[$k]);
							$jpType = substr($jpList[$k], 0, strpos($jpList[$k], "("));
							$jpSig = substr($jpList[$k], strpos($jpList[$k], "(")+1, strrpos($jpList[$k], ")")-  strpos($jpList[$k], "(")-2);
							$aoTable->addAdvice(new AdviceSymbol($jpSig, $adviceT, $jpType, $adviceCode));
						}				
						
						//-----------------------------------------------------------------------------------
						//TODO: ASK WHY IT WAS DONE THIS WAY (OLD ALGORITHM)
						/*
						$jpList = explode("|", $adviceJP);
						echo "\nadviceJP '$adviceJP', size:". count($jpList) ." \n";
						for($k = 0; $k < count($jpList);$k++){
							if($jpList[$k] == "|"){
								$jp = trim($jp);
								$jpType = substr($jp, 0, strpos($jp, "("));
								//echo " - JPType: $jpType\n";	
								$jpSig = substr($jp, strpos($jp, "(")+1, strrpos($jp, ")")- strpos($jp, "(")-1);
								//echo " - Sig: $jpSig\n";
								
								//echo "edding new advice symbol($jpSig, $adviceT, $jpType, $adviceCode)\n\n";
								$aoTable->addAdvice(new AdviceSymbol($jpSig, $adviceT, $jpType, $adviceCode));
								$jp = "";
							}else{
								//echo "appending '{$jpList[$k]}' to jp ($jp)\n\n";
								$jp .= $jpList[$k];
							}
						}			
						
						$first_paren_loc =  strpos($jp, "(");
						$last_paren_loc = strrpos($jp, ")");
						echo "joinpoint: $jp start: $first_paren_loc end: $last_paren_loc\n";
						
						$jpType = substr($jp, 0, $first_paren_loc);						
						echo " - JPType: $jpType\n";
						$jpSig = substr($jp, $first_paren_loc+1, $last_paren_loc - $first_paren_loc-1);
						echo " - Sig: $jpSig\n";
						$aoTable->addAdvice(new AdviceSymbol($jpSig, $adviceT, $jpType, $adviceCode));
						*/
						//------------------------------------------------------------------
						
					} else {
						// Single JP
						$jpType = substr($adviceJP, 0, strpos($adviceJP, "("));
						$jpSig = substr(
							$adviceJP,
							strpos($adviceJP, '(') + 1,
							strrpos($adviceJP, ')') -  strpos($adviceJP, '(') -  2
						);
						$aoTable->addAdvice(new AdviceSymbol($jpSig, $adviceT, $jpType, $adviceCode));
					}
				}
			}
		}
		
		return $aoTable;
	}
		

	/**
	 *
	 * @param string $line
	 * @return bool
	 */
	function startsAdvice($line){
		if(strpos($line,":") === FALSE)
		  return FALSE;
		  
		if(strpos($line,"before") !== FALSE)
		  return TRUE;
		  
		if(strpos($line,"after") !== FALSE)
		  return TRUE;
		  
		if(strpos($line,"around") !== FALSE)
		  return TRUE;
		    
		return FALSE;
	}
	

	/**
	 * 
	 * @param string $curLine
	 * @param file_pointer $in
	 * @return string
	 */
	function grabAdviceBlock($curLine, $in){		
		$code = "";
		$front = "";
		//char
		//$curChar;
		$start = 0;
//		$letCount = 0;
		$brackCount = 0;
		$i = 0;
//		$sCount = 0; // Anything after a // will Break to next line
		$inComment = FALSE;
		$inString = FALSE;
//		$comment = FALSE;
		$foundFB = FALSE;
		$gotFront = FALSE;
		
		if(strpos($curLine, "{") !== FALSE){ // Function Starts on Current Line
			$front = substr($curLine, 0, strpos($curLine, "{")); 
			$gotFront = TRUE;
			$start = strpos($curLine, "{") +1;
			$brackCount++;
			
			// Scan Through Current Line for the Opening Bracket
			for($i=$start;$i < strlen($curLine);$i++){
				$curChar = $curLine[$i];
				if($curChar == '{'){
					if(!$inString && !$inComment){
						$brackCount++;
					}
				}else if($curChar == '}'){
					if(!$inString && !$inComment){
						$brackCount--;
						if($brackCount == 0){
							return $front."#".$code;
						}
					}
				// If an Escape Character, Ignore Next Character
				}else if($curChar == '\\'){
					$i++;
				// Set if In a String or Not
				}else if($curChar == '"'){
					if(!$inComment){
						$inString = !$inString;
					}
				}else if($curChar == '/'){
					if(!$inString){
						if($inComment){
							if($i!=0 && $curLine[$i-1] == '*'){
								$inComment = FALSE;
							}
						}else{
							if($curLine[$i+1] == '*'){
								$inComment = TRUE;
							}else if($curLine[$i+1] == '/'){
								break;
							}
						}						
					}
				}
				$code .= $curChar;
				if($brackCount == 0){
					return $front."#".code;
				}
			}
		}
		
		$foundFB = FALSE;
		if(!$gotFront){
			$front .= $curLine;
		}
		
		while( !feof($in) ){
			//read in the next line of input from the file
			$curLine = fgets($in);
			for($i=0;$i < strlen($curLine);$i++){
				$curChar = $curLine[$i];
				if($curChar == '{'){
					if($brackCount == 0){
						$foundFB = TRUE;
						$gotFront = TRUE;
					}
					if(!$inString && !$inComment){
						$brackCount++;
					}
				}else if($curChar == '}'){
					if(!$inString && !$inComment){
						$brackCount--;
						if($brackCount == 0){
							return $front. "#". $code;
						}
					}
				// If an Escape Character, Ignore Next Character
				}else if($curChar == '\\'){
					$i++;
				// Set if In a String or Not
				}else if($curChar == '"'){
					if(!$inComment){
						$inString = !$inString;
					}
				}else if($curChar == '/'){
					if(!$inString){
						if($inComment){
							if($i!=0 && $curLine[$i-1] == '*'){
								$inComment = FALSE;
							}
						}else{
							if($curLine[$i+1] == '*'){
								$inComment = TRUE;
							}else if($curLine[$i+1] == '/'){
								break;
							}
						}						
					}
				}
				if($foundFB){
					$foundFB = FALSE;
				}else{
					if($gotFront){
						$code .= $curChar;
					}else{
						$front .= $curChar;
					}
					//$code .= $curChar;
				}
				
				if($brackCount == 0){
					return $front . "#" . $code;
				}		
			}
		}

		return $code;
	}

}

?>